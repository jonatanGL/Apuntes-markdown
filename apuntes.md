# Apuntes sobre Clean Code

**Los puntos a destacar son:**

## 1. Nombres Significativos üè∑Ô∏è

Utiliza nombres que reflejen claramente el prop√≥sito y la funci√≥n de las variables, m√©todos y clases en tu c√≥digo. Los nombres descriptivos ayudan a comprender r√°pidamente qu√© hace cada parte del c√≥digo y facilitan su mantenimiento en el futuro. Evita abreviaturas cr√≠pticas o nombres poco descriptivos que requieran una investigaci√≥n adicional para entender su significado. Prioriza la claridad y la expresividad en los nombres sobre la brevedad.

---

## 2. Funciones Peque√±as y Claras üìè

Mant√©n las funciones cortas y enfocadas en una √∫nica tarea espec√≠fica. Las funciones extensas y complejas son dif√≠ciles de entender y de mantener. Divide las funciones largas en piezas m√°s peque√±as y manejables, cada una con una tarea clara y definida. Esto facilita la lectura del c√≥digo y permite reutilizar las funciones en diferentes partes del proyecto.

---

## 3. Comentarios Claros y √ötiles üí¨

Los comentarios en el c√≥digo deben proporcionar informaci√≥n relevante que no est√© clara por s√≠ misma. Utiliza comentarios para explicar el prop√≥sito de una secci√≥n de c√≥digo, las decisiones de dise√±o o cualquier otra informaci√≥n importante que ayude a comprender el contexto del c√≥digo. Mant√©n los comentarios actualizados y elimina los comentarios obsoletos que ya no sean relevantes.

---

## 4. Formato Consistente üìù

La consistencia en el formato del c√≥digo contribuye significativamente a su legibilidad y comprensi√≥n. Adopta una convenci√≥n de formato y estilo de codificaci√≥n coherente en todo el proyecto. Esto incluye la indentaci√≥n, el uso de espacios en blanco, la disposici√≥n de las llaves y cualquier otra convenci√≥n de estilo relevante para el lenguaje de programaci√≥n que est√©s utilizando. Un formato consistente facilita la colaboraci√≥n entre diferentes desarrolladores y mejora la mantenibilidad del c√≥digo.

---

## 5. Elimina C√≥digo Muerto üßπ

Elimina cualquier c√≥digo que est√© comentado, no utilizado o redundante. El c√≥digo muerto solo sirve para confundir a los desarrolladores que intentan entender el c√≥digo y aumenta la complejidad y el mantenimiento del proyecto. Mant√©n el c√≥digo limpio y conciso eliminando cualquier elemento que no contribuya activamente a la funcionalidad del programa.

---

## 6. Refactorizaci√≥n Continua ‚ôªÔ∏è

La refactorizaci√≥n es el proceso de mejorar la estructura interna del c√≥digo sin cambiar su comportamiento externo. Dedica tiempo regularmente a refactorizar el c√≥digo para eliminar la duplicaci√≥n, mejorar la legibilidad y simplificar la l√≥gica. La refactorizaci√≥n continua ayuda a mantener el c√≥digo limpio y mantenible a lo largo del tiempo, lo que facilita su comprensi√≥n y modificaci√≥n por parte de otros desarrolladores.

---

## 7. Pruebas Unitarias üß™

Escribe pruebas unitarias para cada funci√≥n o m√©todo del c√≥digo. Las pruebas unitarias automatizadas son una herramienta invaluable para garantizar que el c√≥digo funcione seg√∫n lo esperado y para detectar r√°pidamente cualquier regresi√≥n o error durante el desarrollo. Las pruebas unitarias bien dise√±adas ayudan a documentar el comportamiento esperado de cada parte del c√≥digo y proporcionan una red de seguridad al realizar cambios en el c√≥digo existente.

---

## 8. Principios SOLID üåü

SOLID es un conjunto de principios de dise√±o de software que promueven la creaci√≥n de c√≥digo limpio, modular y mantenible. Estos principios incluyen el Principio de Responsabilidad √önica (SRP), el Principio Abierto/Cerrado (OCP), el Principio de Sustituci√≥n de Liskov (LSP), el Principio de Segregaci√≥n de Interfaces (ISP) y el Principio de Inversi√≥n de Dependencia (DIP). Siguiendo estos principios, puedes dise√±ar sistemas m√°s flexibles y resistentes a los cambios.

---

## 9. Evita la Duplicaci√≥n de C√≥digo üö´

La duplicaci√≥n de c√≥digo es una fuente de errores y mantenimiento costoso en el desarrollo de software. Busca y elimina cualquier duplicaci√≥n de c√≥digo, ya sea dentro de una misma funci√≥n, entre funciones o en diferentes partes del proyecto. La duplicaci√≥n innecesaria dificulta la comprensi√≥n del c√≥digo y aumenta el riesgo de errores cuando se realizan cambios.
